
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pystellibs.ezmap &#8212; pystellibs 1.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pystellibs.ezmap</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This package is meant to mimic a regular map call with different parallel</span>
<span class="sd">processing handling: built-in map, multiprocessing with given number of cpus,</span>
<span class="sd">etc. It also provides the multiprocessing.map_async with a similar calling</span>
<span class="sd">sequence.</span>

<span class="sd">Example:</span>

<span class="sd">    &gt;&gt;&gt; def fn(a, b, *args, **kwargs):</span>
<span class="sd">           return a, b, args, kwargs</span>

<span class="sd">    &gt;&gt;&gt; print map(partial(fn, a=1, c=2, b=2, allkeywords=True), (3, 4, 5), ncpu=-1)</span>
<span class="sd">    [(1, 2, (3,), {&#39;c&#39;: 2}), (1, 2, (4,), {&#39;c&#39;: 2}), (1, 2, (5,), {&#39;c&#39;: 2})]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">_mp</span>
<span class="kn">import</span> <span class="nn">functools</span> <span class="k">as</span> <span class="nn">_fntools</span>
<span class="kn">import</span> <span class="nn">inspect</span> <span class="k">as</span> <span class="nn">_inspect</span>
<span class="kn">import</span> <span class="nn">time</span> <span class="k">as</span> <span class="nn">_time</span>
<span class="kn">from</span> <span class="nn">multiprocessing.pool</span> <span class="k">import</span> <span class="n">Pool</span> <span class="k">as</span> <span class="n">_Pool</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">getmodule</span> <span class="k">as</span> <span class="n">_getmodule</span>
<span class="kn">import</span> <span class="nn">signal</span> <span class="k">as</span> <span class="nn">_signal</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="ne">TimeoutError</span>
<span class="kn">from</span> <span class="nn">.pbar</span> <span class="k">import</span> <span class="n">Pbar</span> <span class="k">as</span> <span class="n">_PBar</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">,</span> <span class="s1">&#39;map_async&#39;</span><span class="p">,</span> <span class="s1">&#39;Partial&#39;</span><span class="p">,</span> <span class="s1">&#39;allkeywords&#39;</span><span class="p">,</span> <span class="s1">&#39;PicklableLambda&#39;</span><span class="p">,</span> <span class="s1">&#39;async&#39;</span><span class="p">]</span>


<span class="c1">#keep the built-in function</span>
<span class="n">_map</span> <span class="o">=</span> <span class="nb">map</span>


<span class="k">def</span> <span class="nf">_initializer_wrapper</span><span class="p">(</span><span class="n">actual_initializer</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    We ignore SIGINT. It&#39;s up to our parent to kill us in the typical</span>
<span class="sd">    condition of this arising from ``^C`` on a terminal. If someone is</span>
<span class="sd">    manually killing us with that signal, well... nothing will happen.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">_signal</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">_signal</span><span class="o">.</span><span class="n">SIG_IGN</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">actual_initializer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">actual_initializer</span><span class="p">(</span><span class="o">*</span><span class="n">rest</span><span class="p">)</span>


<div class="viewcode-block" id="map"><a class="viewcode-back" href="../../pystellibs.html#pystellibs.ezmap.map">[docs]</a><span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ncpu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Equivalent of `map()` builtin</span>

<span class="sd">    Note: lambda functions are cast to PicklableLambda</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    func: callable</span>
<span class="sd">        function to be mapped over an iterable.</span>

<span class="sd">    iterable: iterable or generator</span>
<span class="sd">        args can be any iterable object. Func will be called over each item.</span>

<span class="sd">    chunksize: int (default None, i.e., equal repartition)</span>
<span class="sd">        number of items per cpu. Default is equal repartition.</span>
<span class="sd">        it chops the iterable into a number of chunks which it submits to the</span>
<span class="sd">        process pool as separate tasks. The (approximate) size of these chunks</span>
<span class="sd">        can be specified by setting chunksize to a positive integer.</span>

<span class="sd">    ncpu: int (default 0, i.e, built-in map behavior)</span>
<span class="sd">        number of cpu to use for the mapping.</span>
<span class="sd">        0 is equivalent to calling the built-in map function</span>
<span class="sd">        &lt;0 is equivalent to requesting all cpus</span>

<span class="sd">    limit: bool (default True)</span>
<span class="sd">        if ncpu is greater than the number of available cpus, setting this</span>
<span class="sd">        keyword will limit the request to the maximum available</span>

<span class="sd">        Note: sometimes the os load controller does awesome and some speed-up</span>
<span class="sd">        could be obtained when requesting more cpus than available</span>

<span class="sd">    progress: bool (default False)</span>
<span class="sd">        if set display a progressbar</span>

<span class="sd">    Outputs</span>
<span class="sd">    -------</span>
<span class="sd">        return an iterable of individual results</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ncpu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">progress</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">iterable</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">progress</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="n">progress</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_PBar</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="n">txt</span><span class="p">)</span><span class="o">.</span><span class="n">iterover</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
                <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">r</span>
    <span class="k">elif</span> <span class="n">progress</span><span class="p">:</span>
        <span class="n">_n</span> <span class="o">=</span> <span class="n">_mp</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ncpu</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># use all available cpus</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">_mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">_n</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">ncpu</span> <span class="o">&gt;</span> <span class="n">_n</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">limit</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">_mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">_n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">_mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">ncpu</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
            <span class="n">iterable</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
        <span class="n">ntasks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">progress</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="n">progress</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="k">with</span> <span class="n">_PBar</span><span class="p">(</span><span class="n">ntasks</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">txt</span><span class="p">)</span> <span class="k">as</span> <span class="n">pb</span><span class="p">:</span>
            <span class="c1"># get the pool working asynchronously</span>
            <span class="k">if</span> <span class="n">islambda</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
                <span class="n">amap</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">map_async</span><span class="p">(</span><span class="n">PicklableLambda</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">chunksize</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">amap</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">map_async</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">chunksize</span><span class="p">)</span>
            <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">_time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">amap</span><span class="o">.</span><span class="n">_number_left</span>
                <span class="n">pb</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ntasks</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">amap</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">map_async</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">chunksize</span><span class="p">,</span> <span class="n">ncpu</span><span class="o">=</span><span class="n">ncpu</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">()</span></div>


<div class="viewcode-block" id="map_async"><a class="viewcode-back" href="../../pystellibs.html#pystellibs.ezmap.map_async">[docs]</a><span class="k">def</span> <span class="nf">map_async</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ncpu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Asynchronous equivalent of `map()` builtin</span>
<span class="sd">    A variant of the map() method which returns a result object.</span>

<span class="sd">    Note: lambda functions are cast to PicklableLambda</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    func: callable</span>
<span class="sd">        function to be mapped over an iterable.</span>

<span class="sd">    iterable: iterable or generator</span>
<span class="sd">        args can be any iterable object. Func will be called over each item.</span>

<span class="sd">    chunksize: int (default None, i.e., equal repartition)</span>
<span class="sd">        number of items per cpu. Default is equal repartition.</span>
<span class="sd">        it chops the iterable into a number of chunks which it submits to the</span>
<span class="sd">        process pool as separate tasks. The (approximate) size of these chunks</span>
<span class="sd">        can be specified by setting chunksize to a positive integer.</span>

<span class="sd">    callback: callable</span>
<span class="sd">        If callback is specified then it should be a callable which accepts a</span>
<span class="sd">        single argument. When the result becomes ready callback is applied to</span>
<span class="sd">        it (unless the call failed). callback should complete immediately since</span>
<span class="sd">        otherwise the thread which handles the results will get blocked.</span>

<span class="sd">    ncpu: int (default 0, i.e, built-in map behavior)</span>
<span class="sd">        number of cpu to use for the mapping.</span>
<span class="sd">        0 is equivalent to calling the built-in map function</span>
<span class="sd">        &lt;0 is equivalent to requesting all cpus</span>

<span class="sd">    limit: bool (default True)</span>
<span class="sd">        if ncpu is greater than the number of available cpus, setting this</span>
<span class="sd">        keyword will limit the request to the maximum available</span>

<span class="sd">        Note: sometimes the os load controller does awesome and some speed-up</span>
<span class="sd">        could be obtained when requesting more cpus than available</span>

<span class="sd">    Outputs</span>
<span class="sd">    -------</span>
<span class="sd">        return an asynchrone descriptor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_n</span> <span class="o">=</span> <span class="n">_mp</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ncpu</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="c1"># use all available cpus</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">_mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">_n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">ncpu</span> <span class="o">&gt;</span> <span class="n">_n</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">limit</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">_mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">_n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">_mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">ncpu</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">islambda</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">map_async</span><span class="p">(</span><span class="n">PicklableLambda</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">chunksize</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">map_async</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">chunksize</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span></div>


<div class="viewcode-block" id="Partial"><a class="viewcode-back" href="../../pystellibs.html#pystellibs.ezmap.Partial">[docs]</a><span class="k">class</span> <span class="nc">Partial</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Partial(func, *args, **keywords) - function class that mimics the</span>
<span class="sd">    functools.partial behavior but makes sure it stays picklable.</span>
<span class="sd">    The new function is a partial application of the given arguments and</span>
<span class="sd">    keywords.  The remaining arguments are sent at the end of the fixed</span>
<span class="sd">    arguments.  Unless you set the allkeywords option, which gives more</span>
<span class="sd">    flexibility to the partial definition.</span>

<span class="sd">    Note: lambda functions are cast to PicklableLambda</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        func: callable</span>
<span class="sd">            the function from which the partial application will be made</span>
<span class="sd">        *args: tuple</span>
<span class="sd">            arguments to fix during the call</span>
<span class="sd">        **kwargs: dict</span>
<span class="sd">            keywords to the function call</span>

<span class="sd">        If &#39;allkeywords&#39; keyword is set (default False) when defining the</span>
<span class="sd">        partial function or in a later call, it allows you to specify arguments</span>
<span class="sd">        and keywords in any order as traditional keywords. The remaining</span>
<span class="sd">        variables will be used to fill the blanks</span>

<span class="sd">    Outputs:</span>
<span class="sd">    ---------</span>
<span class="sd">        returns a callable function with preserved/wrapped documentation names etc.</span>

<span class="sd">    Example:</span>
<span class="sd">    &gt;&gt;&gt; def fn(a, b, *args, **kwargs):</span>
<span class="sd">        ... return a, b, args, kwargs</span>
<span class="sd">    &gt;&gt;&gt; print Partial(fn, 2, c=2)(3, 4, 5, 6, 7)</span>
<span class="sd">        # TypeError: __call__() takes exactly 2 arguments (6 given)</span>
<span class="sd">    &gt;&gt;&gt; print Partial(fn, 2, c=2)(3)</span>
<span class="sd">        # (3, 2, (), {&#39;c&#39;: 2})</span>
<span class="sd">    &gt;&gt;&gt; print Partial(fn, a=1, c=2, b=2, allkeywords=True)(3, 4, 5, 6, 7)</span>
<span class="sd">    &gt;&gt;&gt; print Partial(fun, a=1, b=2)(3, 4, 5, 6, 7, c=3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">islambda</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">PicklableLambda</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="n">_fntools</span><span class="o">.</span><span class="n">update_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Partial(</span><span class="si">{}</span><span class="s1">), args=</span><span class="si">{}</span><span class="s1">, kwargs=</span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fargs</span><span class="p">,</span> <span class="o">**</span><span class="n">fkeywords</span><span class="p">):</span>
        <span class="n">newkeywords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">newkeywords</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fkeywords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">newkeywords</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;allkeywords&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">newkeywords</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;allkeywords&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">allkeywords</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">+</span> <span class="n">fargs</span><span class="p">),</span> <span class="o">**</span><span class="n">newkeywords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">+</span> <span class="n">fargs</span><span class="p">),</span> <span class="o">**</span><span class="n">newkeywords</span><span class="p">)</span></div>


<div class="viewcode-block" id="allkeywords"><a class="viewcode-back" href="../../pystellibs.html#pystellibs.ezmap.allkeywords">[docs]</a><span class="k">def</span> <span class="nf">allkeywords</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator that allows any argument to be set as a keyword. Especially</span>
<span class="sd">    useful for partial function definitions</span>

<span class="sd">    Example:</span>
<span class="sd">    &gt;&gt;&gt; def fn(a, b, *args, **kwargs):</span>
<span class="sd">        ... return a, b, args, kwargs</span>
<span class="sd">    &gt;&gt;&gt; print partial(allkeywords(fn), a=1, c=2, b=2)(3, 4, 5, 6, 7)</span>
<span class="sd">        # normally: TypeError but works now</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@_fntools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">k</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">-</span><span class="n">_inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="n">f</span><span class="p">)):</span>  <span class="c1"># or [0] in 2.5</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span></div>


<span class="k">def</span> <span class="nf">islambda</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Test if the function func is a lambda (&quot;anonymous&quot; function) &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;func_name&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;&lt;lambda&gt;&#39;</span>


<div class="viewcode-block" id="PicklableLambda"><a class="viewcode-back" href="../../pystellibs.html#pystellibs.ezmap.PicklableLambda">[docs]</a><span class="k">class</span> <span class="nc">PicklableLambda</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Class/Decorator that ensures a lambda (&quot;anonymous&quot; function) will be</span>
<span class="sd">    picklable.</span>
<span class="sd">    Lambda are not picklable because they are anonymous while</span>
<span class="sd">    pickling mainly works with the names.  This class digs out the code of the</span>
<span class="sd">    lambda, which is picklable and recreates the lambda function when called.</span>
<span class="sd">    The encapsulated lambda is not anonymous anymore.</span>

<span class="sd">    Notes:</span>
<span class="sd">        * Dependencies are not handled.</span>
<span class="sd">        * Often Partial can replace a lambda definition</span>
<span class="sd">        * map, map_async, Partial from this package automatically cast lambda</span>
<span class="sd">          functions to PicklableLambda.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; f = lambda *args, **kwargs: (args, kwargs)</span>
<span class="sd">        &gt;&gt;&gt; map(PicklableLambda(f), (10, 11), ncpu=-1)</span>
<span class="sd">        [((10,), {}), ((11,), {})]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">islambda</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Object not a lambda function&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_code</span> <span class="o">=</span> <span class="n">_inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_code</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_code</span> <span class="o">+</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_code</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="async"><a class="viewcode-back" href="../../pystellibs.html#pystellibs.ezmap.async">[docs]</a><span class="k">def</span> <span class="nf">async</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    decorator function which makes the decorated function run in a separate</span>
<span class="sd">    Process (asynchronously).  Returns the created Process object.</span>

<span class="sd">    Making async tasks in python is easy. However making async tasks returning</span>
<span class="sd">    values is a pain in the neck due to limitations in Python&#39;s pickling</span>
<span class="sd">    machinery. The trick is to wraps a top-level function around an asynchronous</span>
<span class="sd">    dispatcher.</span>

<span class="sd">    when the decorated function is called, a task is submitted to a</span>
<span class="sd">    process pool, and a future object is returned, providing access to an</span>
<span class="sd">    eventual return value.</span>

<span class="sd">    The future object has a blocking get() method to access the task</span>
<span class="sd">    result: it will return immediately if the job is already done, or block</span>
<span class="sd">    until it completes.</span>

<span class="sd">    This decorator won&#39;t work on methods, due to limitations in Python&#39;s</span>
<span class="sd">    pickling machinery (in principle methods could be made pickleable, but</span>
<span class="sd">    good luck on that).</span>

<span class="sd">    You can also use a common pool to handle multiple async tasks. However,</span>
<span class="sd">    keep in mind that the pool must be generated in the main level</span>

<span class="sd">    Example:</span>

<span class="sd">    &gt;&gt;&gt; @async</span>
<span class="sd">    ... def task1():</span>
<span class="sd">        ... do_something</span>
<span class="sd">    &gt;&gt;&gt; t1 = task1()</span>
<span class="sd">    &gt;&gt;&gt; t1.get()</span>
<span class="sd">    &gt;&gt;&gt; async.pool = Pool(4)</span>
<span class="sd">    &gt;&gt;&gt; t1 = task1()</span>
<span class="sd">    &gt;&gt;&gt; t1.get()</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Keeps the original function visible from the module global namespace,</span>
    <span class="c1"># under a name consistent to its __name__ attribute. This is necessary for</span>
    <span class="c1"># the multiprocessing pickling machinery to work properly.</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">_getmodule</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+=</span> <span class="s1">&#39;_original&#39;</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">islambda</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">_func</span> <span class="o">=</span> <span class="n">PicklableLambda</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="k">async</span><span class="p">,</span> <span class="s1">&#39;pool&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="k">async</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">_func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">_func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">send</span></div>


<span class="k">class</span> <span class="nc">Pool</span><span class="p">(</span><span class="n">_Pool</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Overloadind the built-in class to make a context manager</span>
<span class="sd">    A process pool object which controls a pool of worker processes to</span>
<span class="sd">    which jobs can be submitted. It supports asynchronous results with</span>
<span class="sd">    timeouts and callbacks and has a parallel map implementation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wait_timeout</span> <span class="o">=</span> <span class="mi">3600</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncpu</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initargs</span><span class="o">=</span><span class="p">(),</span>
                 <span class="n">maxtasksperchild</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        INPUTS</span>
<span class="sd">        ------</span>
<span class="sd">        ncpu: int (default 0, i.e, built-in map behavior)</span>
<span class="sd">            number of cpu to use for the mapping.</span>
<span class="sd">            0 is equivalent to calling the built-in map function</span>
<span class="sd">            &lt;0 is equivalent to requesting all cpus</span>

<span class="sd">        initializer: callable</span>
<span class="sd">            if set, each worker process will call initializer(*initargs) when</span>
<span class="sd">            it starts.</span>

<span class="sd">        initargs: tuple</span>
<span class="sd">            arguments to use with the initializer</span>

<span class="sd">        maxtasksperchild: int</span>
<span class="sd">            number of tasks a worker process can complete before it will exit</span>
<span class="sd">            and be replaced with a fresh worker process, to enable unused</span>
<span class="sd">            resources to be freed. The default maxtasksperchild is None, which</span>
<span class="sd">            means worker processes will live as long as the pool.</span>

<span class="sd">        limit: bool (default True)</span>
<span class="sd">            if ncpu is greater than the number of available cpus, setting this</span>
<span class="sd">            keyword will limit the request to the maximum available</span>

<span class="sd">            Note: sometimes the os load controller does awesome and some speed-up</span>
<span class="sd">            could be obtained when requesting more cpus than available</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_n</span> <span class="o">=</span> <span class="n">_mp</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ncpu</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>   <span class="c1"># use all available cpus</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="n">_n</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">ncpu</span> <span class="o">&gt;</span> <span class="n">_n</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">limit</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="n">_n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="n">ncpu</span>

        <span class="n">new_initializer</span> <span class="o">=</span> <span class="n">Partial</span><span class="p">(</span><span class="n">_initializer_wrapper</span><span class="p">,</span> <span class="n">initializer</span><span class="p">)</span>
        <span class="n">_Pool</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">processes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="n">new_initializer</span><span class="p">,</span>
                       <span class="n">initargs</span><span class="o">=</span><span class="n">initargs</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">maxtasksperchild</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equivalent of ``map()`` built-in, without swallowing</span>
<span class="sd">        ``KeyboardInterrupt``.</span>
<span class="sd">        :param func:</span>
<span class="sd">            The function to apply to the items.</span>
<span class="sd">        :param iterable:</span>
<span class="sd">            An iterable of items that will have `func` applied to them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The key magic is that we must call r.get() with a timeout, because</span>
        <span class="c1"># a Condition.wait() without a timeout swallows KeyboardInterrupts.</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_async</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">chunksize</span><span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wait_timeout</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TimeoutError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
                <span class="k">raise</span>
            <span class="c1"># Other exceptions propagate up.</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Pool (ncpu=</span><span class="si">{}</span><span class="s1">)</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">,</span> <span class="n">_Pool</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="nd">@async</span>
    <span class="k">def</span> <span class="nf">printsum</span><span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">summed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="c1">#_time.sleep(0.1)</span>
            <span class="n">summed</span> <span class="o">+=</span> <span class="n">value</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Worker </span><span class="si">%i</span><span class="s2">: sum value is </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">summed</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">summed</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">random</span> <span class="k">import</span> <span class="n">sample</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">async</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">pool</span>

    <span class="n">p</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">printsum</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sample</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Worker </span><span class="si">%i</span><span class="s2">: sum value is </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, M. Fouesneau.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    
    <a href="https://github.com/mfouesneau/pystellibs" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>